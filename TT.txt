make the backend and frontend match with every route capture considering the email and the email user state and every route connected properly note that all endppoints needs to be capture, dont leave any detail, handle properly with flash message (react-native-flash-message) and eveything captured, 
import React, { useState, useEffect } from "react";
import {
  View,
  StyleSheet,
  StatusBar,
  SafeAreaView,
  Text,
  TouchableOpacity,
  TextInput,
  ScrollView,
  FlatList,
  ListRenderItem,
  ActivityIndicator,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { createStackNavigator } from "@react-navigation/stack";
import { useEmailStore } from "@/store/email.store";
import Input from "@/components/input/Input";
import Button from "@/components/button/Button";
import { PRIMARY_CRIMSON } from "@/constants/Colors";

// Define TypeScript interfaces
interface EmailItem {
  id: string;
  sender: string;
  senderEmail?: string;
  time: string;
  subject: string;
  preview: string;
  unread: boolean;
}

const Stack = createStackNavigator();

const InboxScreen = ({ navigation }: any) => {
  const [activeTab, setActiveTab] = useState("All");
  const [searchQuery, setSearchQuery] = useState("");
  const { 
    inbox, 
    sent, 
    drafts, 
    unread, 
    loading, 
    fetchInbox, 
    fetchSent, 
    fetchDrafts, 
    fetchUnread 
  } = useEmailStore();

  const tabs = ["All", "Unread", "Sent", "Drafts"];

  // Format date to time string
  const formatTime = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };

  // Filter emails based on active tab and search query
  const getFilteredEmails = () => {
    let filteredEmails: EmailItem[] = [];

    switch (activeTab) {
      case "Unread":
        filteredEmails = unread.map(email => ({
          id: email.id,
          sender: email.senderEmail || "Unknown Sender",
          time: formatTime(email.createdAt),
          subject: email.subject,
          preview: email.body.substring(0, 50) + (email.body.length > 50 ? "..." : ""),
          unread: true
        }));
        break;
      case "Sent":
        filteredEmails = sent.map(email => ({
          id: email.id,
          sender: email.receiverEmail || "Unknown Recipient",
          time: formatTime(email.createdAt),
          subject: email.subject,
          preview: email.body.substring(0, 50) + (email.body.length > 50 ? "..." : ""),
          unread: false
        }));
        break;
      case "Drafts":
        filteredEmails = drafts.map(email => ({
          id: email.id,
          sender: "Draft",
          time: formatTime(email.createdAt),
          subject: email.subject || "(No subject)",
          preview: email.body.substring(0, 50) + (email.body.length > 50 ? "..." : ""),
          unread: false
        }));
        break;
      default: // "All"
        filteredEmails = inbox.map(email => ({
          id: email.id,
          sender: email.senderEmail || "Unknown Sender",
          time: formatTime(email.createdAt),
          subject: email.subject,
          preview: email.body.substring(0, 50) + (email.body.length > 50 ? "..." : ""),
          unread: email.unread || false
        }));
        break;
    }

    // Apply search filter
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filteredEmails = filteredEmails.filter(email => 
        email.sender.toLowerCase().includes(query) ||
        email.subject.toLowerCase().includes(query) ||
        email.preview.toLowerCase().includes(query)
      );
    }

    return filteredEmails;
  };

  useEffect(() => {
    switch (activeTab) {
      case "All":
        fetchInbox();
        break;
      case "Unread":
        fetchUnread();
        break;
      case "Sent":
        fetchSent();
        break;
      case "Drafts":
        fetchDrafts();
        break;
    }
  }, [activeTab]);

  // Refresh data when component mounts
  useEffect(() => {
    fetchInbox();
  }, []);

  // Properly typed render function
  const renderEmailItem: ListRenderItem<EmailItem> = ({ item }) => (
    <TouchableOpacity style={styles.emailItem}>
      <View style={styles.emailContent}>
        <View style={styles.emailHeader}>
          <Text 
            style={[
              styles.senderText, 
              item.unread && styles.unreadSenderText
            ]}
            numberOfLines={1}
          >
            {item.sender}
          </Text>
          <Text style={styles.timeText}>{item.time}</Text>
        </View>
        {item.subject ? (
          <>
            <Text 
              style={[
                styles.subjectText,
                item.unread && styles.unreadSubjectText
              ]}
              numberOfLines={1}
            >
              {item.subject}
            </Text>
            <Text 
              style={styles.previewText}
              numberOfLines={1}
            >
              {item.preview}
            </Text>
          </>
        ) : (
          <View style={styles.emptyEmail} />
        )}
      </View>
      {item.unread && <View style={styles.unreadIndicator} />}
    </TouchableOpacity>
  );

  const renderEmptyState = () => {
    if (loading) {
      return (
        <View style={styles.emptyContainer}>
          <ActivityIndicator size="large" color="#007AFF" />
          <Text style={styles.emptyText}>Loading emails...</Text>
        </View>
      );
    }

    return (
      <View style={styles.emptyContainer}>
        <Ionicons name="mail-open-outline" size={64} color="#ccc" />
        <Text style={styles.emptyText}>
          {activeTab === "All" ? "No emails in your inbox" :
           activeTab === "Unread" ? "No unread emails" :
           activeTab === "Sent" ? "No sent emails" : "No drafts"}
        </Text>
      </View>
    );
  };

  return (
    <View style={styles.container}>
      <StatusBar barStyle="light-content" backgroundColor="#000" />
      
      {/* Top section with black background */}
      <View style={styles.topSection}>
        <SafeAreaView style={styles.safeAreaTop}>
          {/* Header */}
          <View style={styles.header}>
            <Text style={styles.headerTitle}>Inbox</Text>
            <TouchableOpacity>
              <Ionicons name="notifications-outline" size={24} color="#fff" />
            </TouchableOpacity>
          </View>

          {/* Search Bar */}
          <View style={styles.searchContainer}>
            <Ionicons name="search" size={20} color="#999" style={styles.searchIcon} />
            <TextInput
              style={styles.searchInput}
              placeholder="Search in inbox"
              placeholderTextColor="#999"
              value={searchQuery}
              onChangeText={setSearchQuery}
            />
          </View>

          {/* Compose Button */}
          <TouchableOpacity 
            style={styles.composeButton}
            onPress={() => navigation.navigate("Compose")}
          >
            <Ionicons name="create-outline" size={20} color="#fff" />
            <Text style={styles.composeText}>Compose</Text>
          </TouchableOpacity>

          {/* Tab Bar */}
          <ScrollView 
            horizontal 
            showsHorizontalScrollIndicator={false}
            style={styles.tabContainer}
            contentContainerStyle={styles.tabContent}
          >
            {tabs.map((tab) => (
              <TouchableOpacity
                key={tab}
                style={[styles.tab, activeTab === tab && styles.activeTab]}
                onPress={() => setActiveTab(tab)}
              >
                <Text style={[styles.tabText, activeTab === tab && styles.activeTabText]}>
                  {tab}
                </Text>
                {tab === "Unread" && unread.length > 0 && (
                  <View style={styles.badge}>
                    <Text style={styles.badgeText}>{unread.length}</Text>
                  </View>
                )}
              </TouchableOpacity>
            ))}
          </ScrollView>
        </SafeAreaView>
      </View>

      {/* Bottom section with white background and rounded top corners */}
      <View style={styles.bottomSection}>
        <SafeAreaView style={styles.safeAreaBottom}>
          {/* Email List */}
          <FlatList
            data={getFilteredEmails()}
            renderItem={renderEmailItem}
            keyExtractor={(item: EmailItem) => item.id}
            contentContainerStyle={styles.emailList}
            showsVerticalScrollIndicator={false}
            ListEmptyComponent={renderEmptyState}
            refreshing={loading}
            onRefresh={() => {
              switch (activeTab) {
                case "All": fetchInbox(); break;
                case "Unread": fetchUnread(); break;
                case "Sent": fetchSent(); break;
                case "Drafts": fetchDrafts(); break;
              }
            }}
          />
        </SafeAreaView>
      </View>

      {/* Floating Action Button */}
      <TouchableOpacity 
        style={styles.fab}
        onPress={() => navigation.navigate("Compose")}
      >
        <Ionicons name="add" size={24} color="#fff" />
      </TouchableOpacity>
    </View>
  );
};

const ComposeScreen = ({ navigation, route }: any) => {
  const { sendEmail, loading } = useEmailStore();
  const [receiverEmail, setReceiverEmail] = useState("");
  const [subject, setSubject] = useState("");
  const [body, setBody] = useState("");

  // Pre-fill fields if editing a draft or replying
  useEffect(() => {
    if (route.params?.draft) {
      const draft = route.params.draft;
      setReceiverEmail(draft.receiverEmail || "");
      setSubject(draft.subject || "");
      setBody(draft.body || "");
    }
  }, [route.params]);

  const handleSend = async () => {
    try {
      await sendEmail({ receiverEmail, subject, body });
      navigation.goBack();
    } catch (error) {
      console.error("Failed to send email:", error);
    }
  };

  const handleSaveDraft = async () => {
    try {
      // Implement draft saving logic here
      console.log("Saving draft...");
      // You would need to add a saveDraft function to your store
    } catch (error) {
      console.error("Failed to save draft:", error);
    }
  };

  return (
    <View style={composeStyles.container}>
      <StatusBar barStyle="dark-content" backgroundColor="#fff" />
      
      {/* Header */}
      <View style={composeStyles.header}>
        <TouchableOpacity onPress={() => navigation.goBack()}>
          <Ionicons name="close" size={24} color="#000" />
        </TouchableOpacity>
        <Text style={composeStyles.headerTitle}>Compose</Text>
        <View style={composeStyles.headerActions}>
          <TouchableOpacity onPress={handleSaveDraft} style={composeStyles.saveButton}>
            <Text style={composeStyles.saveButtonText}>Save</Text>
          </TouchableOpacity>
          <TouchableOpacity 
            onPress={handleSend} 
            disabled={loading || !receiverEmail}
            style={[
              composeStyles.sendButton,
              (loading || !receiverEmail) && composeStyles.disabledButton
            ]}
          >
            {loading ? (
              <ActivityIndicator size="small" color="#fff" />
            ) : (
              <Text style={composeStyles.sendButtonText}>Send</Text>
            )}
          </TouchableOpacity>
        </View>
      </View>

      {/* Form */}
      <ScrollView style={composeStyles.form}>
        <Input
          placeholder="To"
          value={receiverEmail}
          onChangeText={setReceiverEmail}
          containerStyle={composeStyles.inputContainer}
          inputStyle={composeStyles.input}
          keyboardType="email-address"
          autoCapitalize="none"
          autoCorrect={false}
        />
        
        <Input
          placeholder="Subject"
          value={subject}
          onChangeText={setSubject}
          containerStyle={composeStyles.inputContainer}
          inputStyle={composeStyles.input}
        />
        
        <TextInput
          style={composeStyles.bodyInput}
          placeholder="Compose your message..."
          value={body}
          onChangeText={setBody}
          multiline
          textAlignVertical="top"
        />
      </ScrollView>

      {/* Action Buttons */}
      <View style={composeStyles.actionBar}>
        <TouchableOpacity style={composeStyles.actionButton}>
          <Ionicons name="attach" size={24} color="#666" />
        </TouchableOpacity>
        <TouchableOpacity style={composeStyles.actionButton}>
          <Ionicons name="image" size={24} color="#666" />
        </TouchableOpacity>
        <TouchableOpacity style={composeStyles.actionButton}>
          <Ionicons name="document" size={24} color="#666" />
        </TouchableOpacity>
        <TouchableOpacity style={composeStyles.actionButton}>
          <Ionicons name="mic" size={24} color="#666" />
        </TouchableOpacity>
      </View>
    </View>
  );
};

const InboxStack = () => {
  return (
    <Stack.Navigator 
      screenOptions={{ 
        headerShown: false,
        cardStyle: { backgroundColor: '#fff' }
      }}
    >
      <Stack.Screen name="Inbox" component={InboxScreen} />
      <Stack.Screen 
        name="Compose" 
        component={ComposeScreen}
        options={{
          presentation: 'modal'
        }}
      />
    </Stack.Navigator>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#000",
  },
  topSection: {
    backgroundColor: "#000",
    paddingBottom: 8,
  },
  bottomSection: {
    flex: 1,
    backgroundColor: "#fff",
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    overflow: "hidden",
  },
  safeAreaTop: {
    backgroundColor: "#000",
  },
  safeAreaBottom: {
    flex: 1,
    backgroundColor: "#fff",
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingHorizontal: 20,
    paddingTop: 16,
    paddingBottom: 8,
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#fff",
  },
  searchContainer: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#1c1c1c",
    marginHorizontal: 20,
    marginVertical: 16,
    borderRadius: 10,
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  searchIcon: {
    marginRight: 10,
  },
  searchInput: {
    flex: 1,
    fontSize: 16,
    color: "#fff",
  },
  composeButton: {
    flexDirection: "row",
    alignItems: "center",
    marginHorizontal: 20,
    marginBottom: 16,
    color: PRIMARY_CRIMSON
  },
  composeText: {
    color: "#fff",
    marginLeft: 8,
    fontSize: 16,
  },
  tabContainer: {
    marginHorizontal: 20,
    marginBottom: 8,
  },
  tabContent: {
    paddingRight: 40,
  },
  tab: {
    flexDirection: "row",
    alignItems: "center",
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 16,
    marginRight: 8,
    backgroundColor: "#1c1c1c",
  },
  activeTab: {
    backgroundColor: "#3a3a3a",
  },
  tabText: {
    color: "#999",
    fontSize: 14,
  },
  activeTabText: {
    color: "#fff",
    fontWeight: "500",
  },
  badge: {
    backgroundColor: "#007AFF",
    borderRadius: 10,
    paddingHorizontal: 6,
    paddingVertical: 2,
    marginLeft: 4,
  },
  badgeText: {
    color: "#fff",
    fontSize: 12,
    fontWeight: "bold",
  },
  emailList: {
    flexGrow: 1,
    paddingHorizontal: 20,
    paddingTop: 16,
  },
  emailItem: {
    flexDirection: "row",
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: "#f0f0f0",
  },
  emailContent: {
    flex: 1,
    marginRight: 8,
  },
  emailHeader: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginBottom: 4,
  },
  senderText: {
    color: "#000",
    fontSize: 16,
    fontWeight: "500",
    flex: 1,
    marginRight: 8,
  },
  unreadSenderText: {
    fontWeight: "bold",
  },
  timeText: {
    color: "#666",
    fontSize: 14,
  },
  subjectText: {
    color: "#000",
    fontSize: 16,
    marginBottom: 2,
  },
  unreadSubjectText: {
    fontWeight: "bold",
  },
  previewText: {
    color: "#666",
    fontSize: 14,
  },
  emptyEmail: {
    height: 20,
  },
  unreadIndicator: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: "#007AFF",
    alignSelf: "center",
  },
  fab: {
    position: "absolute",
    right: 20,
    bottom: 20,
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: "#007AFF",
    alignItems: "center",
    justifyContent: "center",
    elevation: 4,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.3,
    shadowRadius: 3,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 40,
  },
  emptyText: {
    marginTop: 16,
    color: "#666",
    fontSize: 16,
    textAlign: "center",
  },
});

const composeStyles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#fff",
  },
  header: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: "#f0f0f0",
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: "bold",
  },
  headerActions: {
    flexDirection: "row",
    alignItems: "center",
  },
  saveButton: {
    padding: 8,
    marginRight: 12,
  },
  saveButtonText: {
    color: "#666",
    fontSize: 16,
  },
  sendButton: {
    backgroundColor: "#007AFF",
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 6,
  },
  disabledButton: {
    backgroundColor: "#ccc",
  },
  sendButtonText: {
    color: "#fff",
    fontSize: 16,
    fontWeight: "600",
  },
  form: {
    flex: 1,
    padding: 16,
  },
  inputContainer: {
    marginBottom: 16,
  },
  input: {
    borderWidth: 0,
    borderBottomWidth: 1,
    borderBottomColor: "#f0f0f0",
    borderRadius: 0,
    paddingHorizontal: 0,
    paddingVertical: 12,
  },
  bodyInput: {
    flex: 1,
    fontSize: 16,
    minHeight: 200,
    padding: 0,
    marginTop: 16,
  },
  actionBar: {
    flexDirection: "row",
    padding: 16,
    borderTopWidth: 1,
    borderTopColor: "#f0f0f0",
  },
  actionButton: {
    marginRight: 16,
    padding: 8,
  },
});

export default InboxStack;

import { create } from 'zustand';
import emailApi from '../services/email.service';

interface Email {
  id: string;
  subject: string;
  body: string;
  senderEmail: string;
  receiverEmail?: string;
  createdAt: string;
  unread?: boolean;
  isDraft?: boolean;
  attachment:       string[];
  isReadBySender?:   boolean;
  isReadByReceiver?:   boolean;
  isStarred?: boolean;
  isArchived?: boolean;
  isSpam?: boolean;
  isSent?: boolean;
  isReply?: boolean;
  isDeleted?:  boolean;
}

interface EmailState {
  inbox: Email[];
  sent: Email[];
  drafts: Email[];
  unread: Email[];
  loading: boolean;
  error: string | null;

  fetchInbox: () => Promise<void>;
  fetchSent: () => Promise<void>;
  fetchDrafts: () => Promise<void>;
  fetchUnread: () => Promise<void>;

  sendEmail: (data: any, files?: any[]) => Promise<void>;
  deleteEmail: (id: string) => Promise<void>;
}

export const useEmailStore = create<EmailState>((set, get) => ({
  inbox: [],
  sent: [],
  drafts: [],
  unread: [],
  loading: false,
  error: null,

  fetchInbox: async () => {
    set({ loading: true });
    try {
      const { data } = await emailApi.getInbox();
      set({ inbox: data.items ?? [], loading: false });
    } catch (err: any) {
      set({ error: err.message, loading: false });
    }
  },

  fetchSent: async () => {
    try {
      const { data } = await emailApi.getSent();
      set({ sent: data.items ?? [] });
    } catch (err: any) {
      set({ error: err.message });
    }
  },

  fetchDrafts: async () => {
    try {
      const { data } = await emailApi.getDrafts();
      set({ drafts: data.items ?? [] });
    } catch (err: any) {
      set({ error: err.message });
    }
  },

  fetchUnread: async () => {
    try {
      const { data } = await emailApi.getUnread();
      set({ unread: data.items ?? [] });
    } catch (err: any) {
      set({ error: err.message });
    }
  },

  sendEmail: async (payload, files) => {
    try {
      await emailApi.create(payload, files);
      await get().fetchInbox();
    } catch (err: any) {
      set({ error: err.message });
    }
  },

  deleteEmail: async (id) => {
    try {
      await emailApi.delete(id);
      set({ inbox: get().inbox.filter((e) => e.id !== id) });
    } catch (err: any) {
      set({ error: err.message });
    }
  },
}));


import api from './api';

export interface CreateEmailPayload {
  subject: string;
  body: string;
  receiverEmail?: string;
  isDraft?: boolean;
 
}

class EmailApiService {
  getInbox(page = 1, limit = 10, search = '') {
    return api.get(`/emails?search=${search}&page=${page}&limit=${limit}`);
  }

  getCategorized(params: Record<string, any>) {
    return api.get('/emails/user-mails/categorize', { params });
  }

  getById(id: string) {
    return api.get(`/emails/${id}`);
  }

  create(data: CreateEmailPayload, files?: any[]) {
    const formData = new FormData();
    Object.entries(data).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        formData.append(key, value as any);
      }
    });
    if (files) {
      files.forEach((file) => formData.append('files', file));
    }
    return api.post('/emails', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    });
  }

  reply(data: { originalEmailId: string; additionalMessage: string }) {
    return api.post('/emails/reply', data);
  }

  forward(id: string, receiverEmail: string, additionalMessage: string) {
    return api.post(`/emails/forward/${id}`, { receiverEmail, additionalMessage });
  }

  update(id: string, data: Partial<CreateEmailPayload>) {
    return api.patch(`/emails/${id}`, data);
  }

  updateState(id: string, data: { isStarred?: boolean; isArchived?: boolean; isSpam?: boolean }) {
    return api.patch(`/emails/state/${id}`, data);
  }

  delete(id: string) {
    return api.delete(`/emails/${id}`);
  }

  markAsRead(id: string) {
    return api.patch(`/emails/read/${id}`);
  }

  sendDraft(id: string) {
    return api.patch(`/emails/${id}/send`, {});
  }

  getSent() {
    return api.get('/emails/user/sent');
  }

  getDrafts() {
    return api.get('/emails/user/drafts');
  }

  getUnread() {
    return api.get('/emails/user/unread');
  }

  recover(id: string) {
    return api.patch(`/emails/recover/${id}`, {});
  }
}

export default new EmailApiService();

import { Router } from "express";
import { Authorize } from "../middlewares/authorize";
import EmailController from '../controllers/email';
import upload from "../configs/multer";
import { uploadToCloudinary } from "../middlewares/multerCloudinary";

class EmailRouter {
    public router: Router
    authenticateService: Authorize

    constructor() {
        this.router = Router()
        this.authenticateService = new Authorize()
        this.initializeRoutes()
    }

    private initializeRoutes() {
        this.router.use(this.authenticateService.authorize)
        this.router.get('/', EmailController.getUserInbox)
        this.router.post('/', upload.array('files'), uploadToCloudinary, EmailController.createEmail);
        this.router.post('/reply', upload.array('files'), uploadToCloudinary, EmailController.replyToEmail);
        this.router.get('/:emailId', EmailController.getEmailById);
        this.router.post('/forward/:emailId', EmailController.forwardEmail);
        this.router.patch('/:emailId', EmailController.updateEmail);
        this.router.patch('/state/:emailId', EmailController.updateEmailState);
        this.router.delete('/:emailId', EmailController.deleteEmail);
        this.router.get('/user-mails/categorize', EmailController.getUserEmail);
        this.router.get('/user/sent', EmailController.getUserSentEmails);
        this.router.get('/user/:email/drafts', EmailController.getUserDraftEmails);
        this.router.get('/user/unread', EmailController.getUserUnreadEmails);
        this.router.patch('/read/:emailId/', EmailController.markEmailAsRead);
        this.router.patch('/:emailId/send', EmailController.sendDraftEmail);
        // email recovery
        this.router.patch('/recover/:emailId', EmailController.recoverUserEmail);

    }
}
import { Request, Response } from "express";
import EmailService, { EmailQueryOptions } from "../services/emailService";
import { CustomRequest, EmailDataType } from "../utils/types";
import { EmailSchema, updateEmailStateSchema, updateEmailSchema } from "../validations/schemas/chats.schema";
import tenantService from "../services/tenant.service";
import { serverInstance } from '../index';
import ErrorService from "../services/error.service";


interface EmailQueryParams {
    isInbox?: boolean;
    isDraft?: boolean;
    isStarred?: boolean;
    isArchived?: boolean;
    isSpam?: boolean;
    isThrash?: boolean;
    search?: string;
    page?: number;
    limit?: number;
}
class EmailController {

    constructor() {
    }

    createEmail = async (req: CustomRequest, res: Response) => {
        try {

            // Validate request body
            const { error, value } = EmailSchema.validate(req.body);
            if (error) {
                return res.status(400).json({ message: error.details[0].message });
            }
            console.log("Creating email with body:", value);

            const isDraft = value.isDraft ?? false;

            // Handle optional attachment
            const attachment = value.cloudinaryUrls ?? null;

            // Determine sender email
            let senderEmail: string | null = req.user?.email ?? null;
            if (req.user?.tenant?.id) {
                const tenant = await tenantService.getTenantById(req.user?.tenant?.id);
                senderEmail = tenant?.tenantWebUserEmail ?? senderEmail;
            }

            // Prepare email data
            const {
                cloudinaryUrls,
                cloudinaryVideoUrls,
                cloudinaryDocumentUrls,
                cloudinaryAudioUrls,
                receiverEmail,
                ...emailData
            } = value;

            let receiverId: string | null = null;
            let validatedReceiverEmail: string | null = null;

            // Only process receiver for non-draft emails
            if (!isDraft && receiverEmail) {
                // Fetch receiver details
                const receiver = await EmailService.checkUserEmailExists(receiverEmail);
                if (!receiver) {
                    throw new Error('Receiver email not found');
                }
                receiverId = receiver.userId;
                validatedReceiverEmail = receiverEmail;
            }

            // Create email
            const email = await EmailService.createEmail({
                ...emailData,
                senderId: req.user?.id,
                receiverId,
                receiverEmail: validatedReceiverEmail,
                attachment,
                senderEmail,
            }, isDraft);

            if (!email) {
                return res.status(500).json({ message: "Failed to create email" });
            }

            // Only notify recipient for non-draft emails
            if (!isDraft && validatedReceiverEmail) {
                serverInstance.sendToUserEmail(validatedReceiverEmail, "newEmail", email);
            }

            return res.status(201).json({ email });

        } catch (error) {
            ErrorService.handleError(error, res);
        }
    }
    forwardEmail = async (req: CustomRequest, res: Response) => {
        try {

            const { emailId } = req.params;
            const senderId = req.user.id;
            const { receiverEmail, additionalMessage } = req.body;
            if (!receiverEmail) {
                return res.status(400).json({ message: "Receiver email is required" });
            }
            const receiver = await EmailService.checkUserEmailExists(receiverEmail);
            if (!receiver) {
                throw new Error('Receiver email not found');
            }
            // Determine sender email
            let senderEmail: string | null = req.user?.email ?? null;
            if (req.user?.tenant?.id) {
                const tenant = await tenantService.getTenantById(req.user?.tenant?.id);
                senderEmail = tenant?.tenantWebUserEmail ?? senderEmail;
            }

            // Create email
            const email = await EmailService.forwardEmail(emailId, senderId, receiver.userId, senderEmail, receiverEmail, additionalMessage);

            if (!email) {
                return res.status(500).json({ message: "Failed to forward email" });
            }

            return res.status(201).json({ email });

        } catch (error) {
            ErrorService.handleError(error, res);
        }
    }

    /**
  * Get paginated emails with thread support
  */
    getUserInbox = async (req: CustomRequest, res: Response) => {
        try {
            const {
                search
            } = req.query;

            const page = parseInt(req.query.page as string) || 1;
            const limit = parseInt(req.query.limit as string) || 10;

            const result = await EmailService.getInbox(
                req.user.id,
                page,
                limit,
                search ? String(search) : undefined
            );

            res.json(result);
        } catch (error) {
            res.status(400).json({ message: error.message });
        }
    }
    /**
     * Get user emails based on query parameters
     * @param req - Express request object
     * @param res - Express response object
     */
    async getUserEmail(req: CustomRequest, res: Response) {

        try {
            const userId = req.user.id;
            const query = req.query as EmailQueryParams;

            // Map query parameters to category
            // Note: isInbox is handled by default
            let category: EmailQueryOptions['category'] = 'inbox';

            if (query.isStarred) category = 'starred';
            else if (query.isArchived) category = 'archived';
            else if (query.isDraft) category = 'drafts';
            else if (query.isSpam) category = 'spam';
            else if (query.isThrash) category = 'trash';

            // Call the service
            const result = await EmailService.getEmailsForUser(userId, {
                category,
                search: query.search || '',
                page: query.page ? Number(query.page) : 1,
                limit: query.limit ? Number(query.limit) : 10,
                state: {
                    isStarred: query.isStarred,
                    isArchived: query.isArchived,
                    isSpam: query.isSpam,
                    isDeleted: query.isThrash
                }
            });

            res.json(result);
        } catch (error) {
            res.status(500).json({ error: error.message });
        }

    }
    // async getUserEmail(req: CustomRequest, res: Response) {
    //     try {
    //         const { email } = req.user.email ? req.user : req.query;
    //         const {
    //             isDraft,
    //             isStarred,
    //             isArchived,
    //             isSpam,
    //             page = 1,
    //             limit = 10,
    //             search = '',
    //         } = req.query;
    //         console.log("Received request to get user emails with params:", {
    //             email,
    //             isDraft,
    //             isStarred,
    //             isArchived,
    //             isSpam,
    //             page,
    //             limit,
    //             search,
    //         });
    //         const emails = await EmailService.getUserEmailsWithBooleans({
    //             userEmail: email.toString(),
    //             isDraft: isDraft === 'true',
    //             isStarred: isStarred === 'true',
    //             isArchived: isArchived === 'true',
    //             isSpam: isSpam === 'true',
    //             page: parseInt(page as string, 10),
    //             limit: parseInt(limit as string, 10),
    //             search: search as string,
    //         });
    //         res.status(200).json(emails);
    //     } catch (err) {
    //         console.error('Failed to fetch user emails:', err);
    //         res.status(500).json({ error: 'Internal server error' });
    //     }
    // }

    async getEmailById(req: CustomRequest, res: Response) {
        try {
            const emailId = String(req.params.emailId);
            const email = await EmailService.getEmailById(emailId)
            if (!email) return res.status(404).json({ message: "Email not found" })
            return res.status(200).json(email)
        } catch (error) {
            return res.status(500).json({ message: "Failed to get email" })
        }
    }
    async updateEmail(req: CustomRequest, res: Response) {
        try {
            console.log("Received request to update email with ID:", req.params.emailId);
            console.log("Updating email with body:", req.body);
            const emailId = String(req.params.emailId);
            //get the email
            const email = await EmailService.getEmailById(emailId);
            if (!email) return res.status(404).json({ message: 'Email not found' })

            //check userId if he owns the email
            if (email.senderEmail !== String(req.user.email)) {
                return res.status(403).json({ message: 'Forbbiden' })
            }
            // Validate request body
            const { error, value } = updateEmailSchema.validate(req.body);
            if (error) {
                return res.status(400).json({ message: error.details[0].message });
            }

            // Handle optional attachment
            const attachment = value.cloudinaryUrls ?? [];

            // unnecessary fields from the value object (without mutating it)
            const { cloudinaryUrls, cloudinaryVideoUrls, cloudinaryDocumentUrls, cloudinaryAudioUrls, ...emailData } = value;

            const updatedEmail = await EmailService.updateEmail(emailId, { ...emailData, attachment });
            return res.status(200).json(updatedEmail)
        } catch (error) {
            return res.status(500).json({ message: "Failed to update email" })
        }
    }
    async updateEmailState(req: CustomRequest, res: Response) {
        try {
            const emailId = req.params.emailId;
            //get the email
            const email = await EmailService.getEmailById(emailId);
            if (!email) return res.status(404).json({ message: 'Email not found' })

            //check userId if he owns the email
            if (email.senderEmail !== String(req.user.email) && email.receiverEmail !== String(req.user.email)) {
                return res.status(403).json({
                    message: 'Forbidden: You are neither the sender nor the receiver of this email'
                });
            }
            // Validate request body
            const { error, value } = updateEmailStateSchema.validate(req.body);
            if (error) {
                return res.status(400).json({ message: error.details[0].message });
            }


            const updatedEmail = await EmailService.updateEmailState(emailId, req.user.id, { ...value });
            return res.status(200).json(updatedEmail)
        } catch (error) {
            console.error("Error updating email state:", error);
            return res.status(500).json({ message: "Failed to update email" })
        }
    }

    async deleteEmail(req: CustomRequest, res: Response) {
        try {
            const emailId = String(req.params.emailId)
            //get the email
            const email = await EmailService.getEmailById(emailId);
            if (!email) return res.status(404).json({ message: 'Email not found' })

            //check userId if he owns the email
            if (email.senderEmail !== String(req.user.email)) {
                return res.status(403).json({ message: 'Forbbiden' })
            }
            await EmailService.deleteEmail(emailId)
            return res.status(200).json({ message: "Email deleted successfully" })
        } catch (error) {
            return res.status(500).json({ message: "Failed to delete email" })
        }
    }

    async getUserSentEmails(req: CustomRequest, res: Response) {
        try {
            let email = null;
            if (req.user?.tenant?.id) {
                const tenant = await tenantService.getTenantById(req.user?.tenant?.id);
                email = tenant?.tenantWebUserEmail;
            } else {
                email = String(req.user.email);
            }
            const emails = await EmailService.getEmailsForUser(req.user.id, { category: "sent" })

            if (!emails) return res.status(200).json({ message: "No sent emails" })
            return res.status(200).json(emails)
        } catch (error) {
            console.error("Error fetching sent emails:", error);
            return res.status(500).json({ message: "Failed to get sent emails" })
        }
    }

    async getUserDraftEmails(req: CustomRequest, res: Response) {
        try {
            const emails = await EmailService.getEmailsForUser(req.user.id, { category: "drafts" })
            return res.status(200).json(emails)
        } catch (error) {
            return res.status(500).json({ message: "Couldnt get Draft emails" })
        }
    }

    async getUserUnreadEmails(req: CustomRequest, res: Response) {
        try {
            let email = null;
            if (req.user?.tenant?.id) {
                const tenant = await tenantService.getTenantById(req.user?.tenant?.id);
                email = tenant?.tenantWebUserEmail;
            } else {
                email = String(req.user.email);
            }

            const emails = await EmailService.getEmailsForUser(req.user.id, {
                unread: true,
                received: true,    // only messages where user is receiver
                category: 'inbox',
            });
            if (!emails) return res.status(200).json({ message: "No Unread Emails" })
            return res.status(200).json(emails)
        } catch (error) {
            return res.status(500).json({ message: "Couldnt get unread emails" })
        }
    }


    replyToEmail = async (req: CustomRequest, res: Response) => {
        try {
            const { originalEmailId, additionalMessage } = req.body;
            const senderId = req.user.id; // From authentication

            const email = await EmailService.replyToEmail(
                originalEmailId,
                senderId,
                additionalMessage
            );

            res.status(201).json(email);
        } catch (error) {
            res.status(400).json({ message: error.message });
        }
    }


    async markEmailAsRead(req: CustomRequest, res: Response) {
        try {
            const emailId = String(req.params.emailId)
            const email = await EmailService.getEmailById(emailId)
            if (!email) return res.status(404).json({ message: 'Email not found' })

            let receiverEmail = null;

            if (req.user?.tenant?.id) {
                const tenant = await tenantService.getTenantById(req.user?.tenant?.id);
                receiverEmail = tenant?.tenantWebUserEmail;
            } else {
                receiverEmail = String(req.user.email);
            }
            const isReciever = email.receiverEmail === receiverEmail;

            if (email.senderEmail !== receiverEmail && !isReciever) {
                return res.status(403).json({ message: 'Forbbiden' })
            }
            const updatedEmail = await EmailService.markEmailAsRead(emailId, isReciever)
            return res.status(200).json(updatedEmail)
        } catch (error) {
            return res.status(500).json({ message: "Couldnt read email" })
        }
    }

    async sendDraftEmail(req: CustomRequest, res: Response) {
        try {
            const emailId = String(req.params.emailId)

            const email = await EmailService.getEmailById(emailId)
            if (!email) return res.status(404).json({ message: 'Email not found' })

            if (email.senderEmail !== String(req.user.email)) {
                return res.status(403).json({ message: 'Forbbiden' })
            }
            const sentEmail = await EmailService.sendDraftEmail(emailId)
            return res.status(200).json(sentEmail)
        } catch (error) {
            return res.status(500).json({ message: "Couldn't send email" })
        }
    }

    async recoverUserEmail(req: CustomRequest, res: Response) {
        try {
            const { emailId } = req.params;
            const userId = req.user.id;

            const updatedState = await EmailService.recoverEmail(emailId, userId);

            res.status(200).json({
                message: 'Email recovered successfully',
                state: updatedState
            });
        } catch (error) {
            res.status(400).json({ message: error.message });
        }
    }
}

export default new EmailController()

export default new EmailRouter().router
model Email {
    id               String   @id @default(cuid())
    senderEmail      String
    receiverEmail    String?
    subject          String?
    body             String
    attachment       String[]
    isReadBySender   Boolean  @default(true)
    isReadByReceiver Boolean  @default(false)
    isDraft          Boolean  @default(false)
    isStarred          Boolean  @default(false)
    isArchived          Boolean  @default(false)
    isSpam          Boolean  @default(false)
    isSent           Boolean  @default(false)
    isReply           Boolean  @default(false)
    isDeleted           Boolean  @default(false)
    createdAt        DateTime @default(now())
    
    // Threading relationships
    threadId         String?  // Root email ID for the thread
    parentEmailId    String?  // Direct parent email ID
    
    // Relations
    senderId         String
    sender           users    @relation("SentEmails", fields: [senderId], references: [id])
    receiverId       String?
    receiver         users?    @relation("ReceivedEmails", fields: [receiverId], references: [id])
    
    // Corrected threading relations
    parentEmail      Email?   @relation("EmailReplies", fields: [parentEmailId], references: [id])
    replies          Email[]  @relation("EmailReplies")
    // NEW: Per-user state tracking
    states           UserEmailState[]
}

model UserEmailState {
    id        String  @id @default(cuid())
    emailId   String
    email     Email   @relation(fields: [emailId], references: [id])
    userId    String
    user      users   @relation(fields: [userId], references: [id])
    
    // Per-user state flags
    isRead    Boolean @default(false)
    isStarred Boolean @default(false)
    isDraft Boolean @default(false)
    isArchived Boolean @default(false)
    isSpam    Boolean @default(false)
    isDeleted Boolean @default(false)
    
    // Unique constraint per user per email
    @@unique([emailId, userId])
}